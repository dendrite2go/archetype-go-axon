// Code generated by protoc-gen-go. DO NOT EDIT.
// source: command.proto

package axonserver

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// An instruction from the components that provides the Command Handler towards AxonServer.
type CommandProviderOutbound struct {
	// The instruction for AxonServer
	//
	// Types that are valid to be assigned to Request:
	//	*CommandProviderOutbound_Subscribe
	//	*CommandProviderOutbound_Unsubscribe
	//	*CommandProviderOutbound_FlowControl
	//	*CommandProviderOutbound_CommandResponse
	//	*CommandProviderOutbound_Ack
	Request isCommandProviderOutbound_Request `protobuf_oneof:"request"`
	// Instruction identifier. If this identifier is set, this instruction will be acknowledged via inbound stream
	InstructionId        string   `protobuf:"bytes,6,opt,name=instruction_id,json=instructionId,proto3" json:"instruction_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandProviderOutbound) Reset()         { *m = CommandProviderOutbound{} }
func (m *CommandProviderOutbound) String() string { return proto.CompactTextString(m) }
func (*CommandProviderOutbound) ProtoMessage()    {}
func (*CommandProviderOutbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{0}
}

func (m *CommandProviderOutbound) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandProviderOutbound.Unmarshal(m, b)
}
func (m *CommandProviderOutbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandProviderOutbound.Marshal(b, m, deterministic)
}
func (m *CommandProviderOutbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandProviderOutbound.Merge(m, src)
}
func (m *CommandProviderOutbound) XXX_Size() int {
	return xxx_messageInfo_CommandProviderOutbound.Size(m)
}
func (m *CommandProviderOutbound) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandProviderOutbound.DiscardUnknown(m)
}

var xxx_messageInfo_CommandProviderOutbound proto.InternalMessageInfo

type isCommandProviderOutbound_Request interface {
	isCommandProviderOutbound_Request()
}

type CommandProviderOutbound_Subscribe struct {
	Subscribe *CommandSubscription `protobuf:"bytes,1,opt,name=subscribe,proto3,oneof"`
}

type CommandProviderOutbound_Unsubscribe struct {
	Unsubscribe *CommandSubscription `protobuf:"bytes,2,opt,name=unsubscribe,proto3,oneof"`
}

type CommandProviderOutbound_FlowControl struct {
	FlowControl *FlowControl `protobuf:"bytes,3,opt,name=flow_control,json=flowControl,proto3,oneof"`
}

type CommandProviderOutbound_CommandResponse struct {
	CommandResponse *CommandResponse `protobuf:"bytes,4,opt,name=command_response,json=commandResponse,proto3,oneof"`
}

type CommandProviderOutbound_Ack struct {
	Ack *InstructionAck `protobuf:"bytes,5,opt,name=ack,proto3,oneof"`
}

func (*CommandProviderOutbound_Subscribe) isCommandProviderOutbound_Request() {}

func (*CommandProviderOutbound_Unsubscribe) isCommandProviderOutbound_Request() {}

func (*CommandProviderOutbound_FlowControl) isCommandProviderOutbound_Request() {}

func (*CommandProviderOutbound_CommandResponse) isCommandProviderOutbound_Request() {}

func (*CommandProviderOutbound_Ack) isCommandProviderOutbound_Request() {}

func (m *CommandProviderOutbound) GetRequest() isCommandProviderOutbound_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *CommandProviderOutbound) GetSubscribe() *CommandSubscription {
	if x, ok := m.GetRequest().(*CommandProviderOutbound_Subscribe); ok {
		return x.Subscribe
	}
	return nil
}

func (m *CommandProviderOutbound) GetUnsubscribe() *CommandSubscription {
	if x, ok := m.GetRequest().(*CommandProviderOutbound_Unsubscribe); ok {
		return x.Unsubscribe
	}
	return nil
}

func (m *CommandProviderOutbound) GetFlowControl() *FlowControl {
	if x, ok := m.GetRequest().(*CommandProviderOutbound_FlowControl); ok {
		return x.FlowControl
	}
	return nil
}

func (m *CommandProviderOutbound) GetCommandResponse() *CommandResponse {
	if x, ok := m.GetRequest().(*CommandProviderOutbound_CommandResponse); ok {
		return x.CommandResponse
	}
	return nil
}

func (m *CommandProviderOutbound) GetAck() *InstructionAck {
	if x, ok := m.GetRequest().(*CommandProviderOutbound_Ack); ok {
		return x.Ack
	}
	return nil
}

func (m *CommandProviderOutbound) GetInstructionId() string {
	if m != nil {
		return m.InstructionId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CommandProviderOutbound) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CommandProviderOutbound_Subscribe)(nil),
		(*CommandProviderOutbound_Unsubscribe)(nil),
		(*CommandProviderOutbound_FlowControl)(nil),
		(*CommandProviderOutbound_CommandResponse)(nil),
		(*CommandProviderOutbound_Ack)(nil),
	}
}

// An instruction or confirmation from AxonServer towards the component that provides the Command Handler
type CommandProviderInbound struct {
	// The instruction from AxonServer for this component
	//
	// Types that are valid to be assigned to Request:
	//	*CommandProviderInbound_Ack
	//	*CommandProviderInbound_Command
	Request isCommandProviderInbound_Request `protobuf_oneof:"request"`
	// Instruction identifier. If this identifier is set, this instruction will be acknowledged via outbound stream
	InstructionId        string   `protobuf:"bytes,3,opt,name=instruction_id,json=instructionId,proto3" json:"instruction_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandProviderInbound) Reset()         { *m = CommandProviderInbound{} }
func (m *CommandProviderInbound) String() string { return proto.CompactTextString(m) }
func (*CommandProviderInbound) ProtoMessage()    {}
func (*CommandProviderInbound) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{1}
}

func (m *CommandProviderInbound) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandProviderInbound.Unmarshal(m, b)
}
func (m *CommandProviderInbound) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandProviderInbound.Marshal(b, m, deterministic)
}
func (m *CommandProviderInbound) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandProviderInbound.Merge(m, src)
}
func (m *CommandProviderInbound) XXX_Size() int {
	return xxx_messageInfo_CommandProviderInbound.Size(m)
}
func (m *CommandProviderInbound) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandProviderInbound.DiscardUnknown(m)
}

var xxx_messageInfo_CommandProviderInbound proto.InternalMessageInfo

type isCommandProviderInbound_Request interface {
	isCommandProviderInbound_Request()
}

type CommandProviderInbound_Ack struct {
	Ack *InstructionAck `protobuf:"bytes,1,opt,name=ack,proto3,oneof"`
}

type CommandProviderInbound_Command struct {
	Command *Command `protobuf:"bytes,2,opt,name=command,proto3,oneof"`
}

func (*CommandProviderInbound_Ack) isCommandProviderInbound_Request() {}

func (*CommandProviderInbound_Command) isCommandProviderInbound_Request() {}

func (m *CommandProviderInbound) GetRequest() isCommandProviderInbound_Request {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *CommandProviderInbound) GetAck() *InstructionAck {
	if x, ok := m.GetRequest().(*CommandProviderInbound_Ack); ok {
		return x.Ack
	}
	return nil
}

func (m *CommandProviderInbound) GetCommand() *Command {
	if x, ok := m.GetRequest().(*CommandProviderInbound_Command); ok {
		return x.Command
	}
	return nil
}

func (m *CommandProviderInbound) GetInstructionId() string {
	if m != nil {
		return m.InstructionId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*CommandProviderInbound) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*CommandProviderInbound_Ack)(nil),
		(*CommandProviderInbound_Command)(nil),
	}
}

// A message representing a Command that needs to be routed to a component capable of handling it
type Command struct {
	// The unique identifier of the Command Message
	MessageIdentifier string `protobuf:"bytes,1,opt,name=message_identifier,json=messageIdentifier,proto3" json:"message_identifier,omitempty"`
	// The name of the command, used for routing it to a destination capable of handling it
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// The time at which the command was dispatched
	Timestamp int64 `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	// The payload of the Command, providing details on the instructions for the recipient
	Payload *SerializedObject `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	// Meta Data entries of the Command Message, providing contextual information to the recipient
	MetaData map[string]*MetaDataValue `protobuf:"bytes,5,rep,name=meta_data,json=metaData,proto3" json:"meta_data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Instructions for AxonServer when routing this Command Message
	ProcessingInstructions []*ProcessingInstruction `protobuf:"bytes,6,rep,name=processing_instructions,json=processingInstructions,proto3" json:"processing_instructions,omitempty"`
	// The unique identifier of the component dispatching this message
	ClientId string `protobuf:"bytes,7,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// The name/type of the component dispatching this message
	ComponentName        string   `protobuf:"bytes,8,opt,name=component_name,json=componentName,proto3" json:"component_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Command) Reset()         { *m = Command{} }
func (m *Command) String() string { return proto.CompactTextString(m) }
func (*Command) ProtoMessage()    {}
func (*Command) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{2}
}

func (m *Command) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Command.Unmarshal(m, b)
}
func (m *Command) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Command.Marshal(b, m, deterministic)
}
func (m *Command) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Command.Merge(m, src)
}
func (m *Command) XXX_Size() int {
	return xxx_messageInfo_Command.Size(m)
}
func (m *Command) XXX_DiscardUnknown() {
	xxx_messageInfo_Command.DiscardUnknown(m)
}

var xxx_messageInfo_Command proto.InternalMessageInfo

func (m *Command) GetMessageIdentifier() string {
	if m != nil {
		return m.MessageIdentifier
	}
	return ""
}

func (m *Command) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Command) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Command) GetPayload() *SerializedObject {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Command) GetMetaData() map[string]*MetaDataValue {
	if m != nil {
		return m.MetaData
	}
	return nil
}

func (m *Command) GetProcessingInstructions() []*ProcessingInstruction {
	if m != nil {
		return m.ProcessingInstructions
	}
	return nil
}

func (m *Command) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *Command) GetComponentName() string {
	if m != nil {
		return m.ComponentName
	}
	return ""
}

// Message representing the result of Command Handler execution
type CommandResponse struct {
	// The unique identifier of the response message
	MessageIdentifier string `protobuf:"bytes,1,opt,name=message_identifier,json=messageIdentifier,proto3" json:"message_identifier,omitempty"`
	// An error code describing the error, if any
	ErrorCode string `protobuf:"bytes,2,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	// A detailed description of the error
	ErrorMessage *ErrorMessage `protobuf:"bytes,3,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
	// The payload to provide as a result to the dispatcher
	Payload *SerializedObject `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	// Any meta data entries providing contextual information back to the dispatcher
	MetaData map[string]*MetaDataValue `protobuf:"bytes,5,rep,name=meta_data,json=metaData,proto3" json:"meta_data,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Instructions for AxonServer when routing this Command Response Message
	ProcessingInstructions []*ProcessingInstruction `protobuf:"bytes,6,rep,name=processing_instructions,json=processingInstructions,proto3" json:"processing_instructions,omitempty"`
	// The unique identifier of the Command Message for which this is the response
	RequestIdentifier    string   `protobuf:"bytes,7,opt,name=request_identifier,json=requestIdentifier,proto3" json:"request_identifier,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandResponse) Reset()         { *m = CommandResponse{} }
func (m *CommandResponse) String() string { return proto.CompactTextString(m) }
func (*CommandResponse) ProtoMessage()    {}
func (*CommandResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{3}
}

func (m *CommandResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandResponse.Unmarshal(m, b)
}
func (m *CommandResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandResponse.Marshal(b, m, deterministic)
}
func (m *CommandResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandResponse.Merge(m, src)
}
func (m *CommandResponse) XXX_Size() int {
	return xxx_messageInfo_CommandResponse.Size(m)
}
func (m *CommandResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommandResponse proto.InternalMessageInfo

func (m *CommandResponse) GetMessageIdentifier() string {
	if m != nil {
		return m.MessageIdentifier
	}
	return ""
}

func (m *CommandResponse) GetErrorCode() string {
	if m != nil {
		return m.ErrorCode
	}
	return ""
}

func (m *CommandResponse) GetErrorMessage() *ErrorMessage {
	if m != nil {
		return m.ErrorMessage
	}
	return nil
}

func (m *CommandResponse) GetPayload() *SerializedObject {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CommandResponse) GetMetaData() map[string]*MetaDataValue {
	if m != nil {
		return m.MetaData
	}
	return nil
}

func (m *CommandResponse) GetProcessingInstructions() []*ProcessingInstruction {
	if m != nil {
		return m.ProcessingInstructions
	}
	return nil
}

func (m *CommandResponse) GetRequestIdentifier() string {
	if m != nil {
		return m.RequestIdentifier
	}
	return ""
}

// Message describing a component's capability of handling a command type
type CommandSubscription struct {
	// A unique identifier for this subscription. This identifier is returned in Acknowledgements to allow
	//pipelining of subscription messages
	MessageId string `protobuf:"bytes,1,opt,name=message_id,json=messageId,proto3" json:"message_id,omitempty"`
	// The name of the command the component can handle
	Command string `protobuf:"bytes,2,opt,name=command,proto3" json:"command,omitempty"`
	// The name/type of the component handling the command
	ComponentName string `protobuf:"bytes,3,opt,name=component_name,json=componentName,proto3" json:"component_name,omitempty"`
	// The unique identifier of the component instance subscribing
	ClientId string `protobuf:"bytes,4,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// A number that represents the client's relative load capacity compared to other clients.
	//This information is interpreted by Axon Server in relation to the other connected nodes' values.
	//Used to balance the dispatching of commands. If set to 0, Axon Server consider 100 as default value.
	LoadFactor           int32    `protobuf:"varint,5,opt,name=load_factor,json=loadFactor,proto3" json:"load_factor,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommandSubscription) Reset()         { *m = CommandSubscription{} }
func (m *CommandSubscription) String() string { return proto.CompactTextString(m) }
func (*CommandSubscription) ProtoMessage()    {}
func (*CommandSubscription) Descriptor() ([]byte, []int) {
	return fileDescriptor_213c0bb044472049, []int{4}
}

func (m *CommandSubscription) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CommandSubscription.Unmarshal(m, b)
}
func (m *CommandSubscription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CommandSubscription.Marshal(b, m, deterministic)
}
func (m *CommandSubscription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommandSubscription.Merge(m, src)
}
func (m *CommandSubscription) XXX_Size() int {
	return xxx_messageInfo_CommandSubscription.Size(m)
}
func (m *CommandSubscription) XXX_DiscardUnknown() {
	xxx_messageInfo_CommandSubscription.DiscardUnknown(m)
}

var xxx_messageInfo_CommandSubscription proto.InternalMessageInfo

func (m *CommandSubscription) GetMessageId() string {
	if m != nil {
		return m.MessageId
	}
	return ""
}

func (m *CommandSubscription) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *CommandSubscription) GetComponentName() string {
	if m != nil {
		return m.ComponentName
	}
	return ""
}

func (m *CommandSubscription) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *CommandSubscription) GetLoadFactor() int32 {
	if m != nil {
		return m.LoadFactor
	}
	return 0
}

func init() {
	proto.RegisterType((*CommandProviderOutbound)(nil), "io.axoniq.axonserver.grpc.command.CommandProviderOutbound")
	proto.RegisterType((*CommandProviderInbound)(nil), "io.axoniq.axonserver.grpc.command.CommandProviderInbound")
	proto.RegisterType((*Command)(nil), "io.axoniq.axonserver.grpc.command.Command")
	proto.RegisterMapType((map[string]*MetaDataValue)(nil), "io.axoniq.axonserver.grpc.command.Command.MetaDataEntry")
	proto.RegisterType((*CommandResponse)(nil), "io.axoniq.axonserver.grpc.command.CommandResponse")
	proto.RegisterMapType((map[string]*MetaDataValue)(nil), "io.axoniq.axonserver.grpc.command.CommandResponse.MetaDataEntry")
	proto.RegisterType((*CommandSubscription)(nil), "io.axoniq.axonserver.grpc.command.CommandSubscription")
}

func init() {
	proto.RegisterFile("command.proto", fileDescriptor_213c0bb044472049)
}

var fileDescriptor_213c0bb044472049 = []byte{
	// 778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x56, 0xff, 0x6e, 0x02, 0x45,
	0x10, 0xe6, 0x7a, 0x50, 0xb8, 0xa1, 0xf4, 0xc7, 0x9a, 0xb4, 0x17, 0xaa, 0xb1, 0x92, 0xa8, 0xa8,
	0x29, 0x6d, 0x30, 0x31, 0xb5, 0x89, 0x46, 0xfb, 0x2b, 0x10, 0xad, 0x6d, 0xae, 0xb1, 0x7f, 0x34,
	0x31, 0x97, 0x65, 0x6f, 0xc1, 0x95, 0xbb, 0xdd, 0xeb, 0xde, 0x42, 0xad, 0x6f, 0xa0, 0x0f, 0xe1,
	0x4b, 0xf8, 0x24, 0x26, 0x3e, 0x86, 0x0f, 0x61, 0xee, 0x6e, 0xe1, 0x00, 0x09, 0x85, 0x6a, 0x8c,
	0x7f, 0x71, 0x3b, 0xb3, 0xdf, 0x37, 0x33, 0x3b, 0xdf, 0xec, 0x02, 0x15, 0x22, 0x82, 0x00, 0x73,
	0xaf, 0x11, 0x4a, 0xa1, 0x04, 0x7a, 0x87, 0x89, 0x06, 0xfe, 0x51, 0x70, 0xf6, 0x98, 0xfc, 0x44,
	0x54, 0x0e, 0xa9, 0x6c, 0xf4, 0x64, 0x48, 0x1a, 0x7a, 0x63, 0x75, 0x23, 0xfe, 0x10, 0x3c, 0x05,
	0xd4, 0xfe, 0x34, 0x61, 0xef, 0x3c, 0xf5, 0xdc, 0x4a, 0x31, 0x64, 0x1e, 0x95, 0x37, 0x03, 0xd5,
	0x11, 0x03, 0xee, 0xa1, 0x7b, 0xb0, 0xa2, 0x41, 0x27, 0x22, 0x92, 0x75, 0xa8, 0x6d, 0x1c, 0x18,
	0xf5, 0x72, 0xf3, 0x93, 0xc6, 0x8b, 0x01, 0x1a, 0x9a, 0xee, 0x2e, 0x85, 0x86, 0x8a, 0x09, 0xde,
	0xca, 0x39, 0x19, 0x15, 0x7a, 0x80, 0xf2, 0x80, 0x67, 0xcc, 0x6b, 0xff, 0x90, 0x79, 0x92, 0x0c,
	0x7d, 0x05, 0x1b, 0x5d, 0x5f, 0x3c, 0xb9, 0x44, 0x70, 0x25, 0x85, 0x6f, 0x9b, 0x09, 0xf9, 0x7b,
	0x0b, 0xc8, 0xaf, 0x7c, 0xf1, 0x74, 0x9e, 0xee, 0x8e, 0xc9, 0xba, 0xd9, 0x12, 0xb9, 0xb0, 0xad,
	0x43, 0xbb, 0x92, 0x46, 0x61, 0x8c, 0xb3, 0xf3, 0x09, 0x61, 0x73, 0xf9, 0x6c, 0x1d, 0x8d, 0x6c,
	0xe5, 0x9c, 0x2d, 0x32, 0x6d, 0x42, 0x9f, 0x81, 0x89, 0x49, 0xdf, 0x2e, 0x24, 0x9c, 0x1f, 0x2c,
	0xe0, 0x6c, 0xf3, 0x48, 0xc9, 0x01, 0x89, 0x2b, 0xfe, 0x92, 0xf4, 0x5b, 0x39, 0x27, 0xc6, 0xa1,
	0x77, 0x61, 0x93, 0x65, 0x0e, 0x97, 0x79, 0xf6, 0xfa, 0x81, 0x51, 0xb7, 0x9c, 0xca, 0x84, 0xb5,
	0xed, 0x9d, 0x59, 0x50, 0x94, 0xf4, 0x71, 0x40, 0x23, 0x55, 0xfb, 0xdd, 0x80, 0xdd, 0x99, 0x76,
	0xb7, 0x79, 0xda, 0x6d, 0x9d, 0x8b, 0xf1, 0xca, 0x5c, 0xae, 0xa0, 0xa8, 0xab, 0xd3, 0x0d, 0xfd,
	0x70, 0xf9, 0x23, 0x6a, 0xe5, 0x9c, 0x11, 0x78, 0x4e, 0x4d, 0xe6, 0x0b, 0x35, 0xfd, 0x9a, 0x87,
	0xa2, 0x26, 0x42, 0x87, 0x80, 0x02, 0x1a, 0x45, 0xb8, 0x47, 0x5d, 0xe6, 0x51, 0xae, 0x58, 0x97,
	0x51, 0x99, 0xd4, 0x64, 0x39, 0x3b, 0xda, 0xd3, 0x1e, 0x3b, 0x10, 0x82, 0x3c, 0xc7, 0x41, 0x2a,
	0x41, 0xcb, 0x49, 0xbe, 0xd1, 0x9b, 0x60, 0x29, 0x16, 0xd0, 0x48, 0xe1, 0x20, 0x4c, 0x62, 0x9b,
	0x4e, 0x66, 0x40, 0x97, 0x50, 0x0c, 0xf1, 0xb3, 0x2f, 0xb0, 0xa7, 0x95, 0xf0, 0xd1, 0x82, 0x32,
	0xef, 0xa8, 0x64, 0xd8, 0x67, 0x3f, 0x51, 0xef, 0xa6, 0xf3, 0x03, 0x25, 0xca, 0x19, 0x61, 0xd1,
	0xb7, 0x60, 0x05, 0x54, 0x61, 0xd7, 0xc3, 0x0a, 0xdb, 0x85, 0x03, 0xb3, 0x5e, 0x6e, 0x9e, 0x2c,
	0x7f, 0x5e, 0x8d, 0x6b, 0xaa, 0xf0, 0x05, 0x56, 0xf8, 0x92, 0x2b, 0xf9, 0xec, 0x94, 0x02, 0xbd,
	0x44, 0x0c, 0xf6, 0x42, 0x29, 0x08, 0x8d, 0x22, 0xc6, 0x7b, 0xee, 0xc4, 0x89, 0x45, 0xf6, 0x7a,
	0x12, 0xe4, 0x78, 0x41, 0x90, 0xdb, 0x31, 0x72, 0xa2, 0xc3, 0xce, 0x6e, 0x38, 0xcf, 0x1c, 0xa1,
	0x7d, 0xb0, 0x88, 0xcf, 0x28, 0x57, 0x71, 0x8b, 0x8a, 0xc9, 0xf9, 0x95, 0x52, 0x43, 0x3b, 0x69,
	0x22, 0x11, 0x41, 0x28, 0x78, 0xec, 0x4f, 0x4e, 0xb8, 0x94, 0x36, 0x71, 0x6c, 0xfd, 0x06, 0x07,
	0xb4, 0x4a, 0xa1, 0x32, 0x55, 0x09, 0xda, 0x06, 0xb3, 0x4f, 0x9f, 0x75, 0xbf, 0xe2, 0x4f, 0xf4,
	0x39, 0x14, 0x86, 0xd8, 0x1f, 0x8c, 0x6e, 0x89, 0xfa, 0x82, 0xfc, 0x47, 0x54, 0xf7, 0xf1, 0x7e,
	0x27, 0x85, 0x9d, 0xae, 0x9d, 0x18, 0xb5, 0x3f, 0xf2, 0xb0, 0x35, 0x33, 0x8c, 0xab, 0x0a, 0xe5,
	0x2d, 0x00, 0x2a, 0xa5, 0x90, 0x2e, 0x11, 0xde, 0x48, 0x2e, 0x56, 0x62, 0x39, 0x17, 0x1e, 0x45,
	0x5f, 0x43, 0x25, 0x75, 0x6b, 0xa4, 0xbe, 0x76, 0xde, 0x5f, 0x90, 0xed, 0x65, 0xbc, 0xff, 0x3a,
	0xdd, 0xee, 0x6c, 0xd0, 0x89, 0xd5, 0xbf, 0xa5, 0xb1, 0xef, 0xfe, 0xae, 0xb1, 0x2f, 0x56, 0xbf,
	0xb6, 0xfe, 0x0f, 0x5a, 0x3b, 0x04, 0xa4, 0x87, 0x7d, 0xb2, 0x59, 0xa9, 0xe8, 0x76, 0xb4, 0x27,
	0x6b, 0xd6, 0x7f, 0x25, 0xab, 0xdf, 0x0c, 0x78, 0x63, 0xce, 0x8b, 0x14, 0x6b, 0x25, 0x93, 0x96,
	0x0e, 0x6a, 0x8d, 0x25, 0x85, 0xec, 0xe9, 0x8b, 0xd2, 0x9a, 0xba, 0xfa, 0x66, 0xa6, 0xc6, 0x9c,
	0x33, 0x35, 0xd3, 0x93, 0x97, 0x9f, 0x99, 0xbc, 0xb7, 0xa1, 0x1c, 0x37, 0xdf, 0xed, 0x62, 0xa2,
	0x84, 0x4c, 0x5e, 0x96, 0x82, 0x03, 0xb1, 0xe9, 0x2a, 0xb1, 0x34, 0x7f, 0x59, 0x83, 0xcd, 0x51,
	0xd6, 0x54, 0x0e, 0x19, 0xa1, 0xe8, 0x67, 0x03, 0xe0, 0x26, 0xa4, 0xfc, 0x4e, 0x49, 0x8a, 0x03,
	0x74, 0xba, 0xbc, 0x48, 0x66, 0xff, 0x32, 0x54, 0x3f, 0x5d, 0x1d, 0xab, 0xdf, 0x9f, 0x5a, 0xae,
	0x6e, 0x1c, 0x1b, 0xc8, 0x87, 0xd2, 0x05, 0x8b, 0x42, 0xac, 0xc8, 0xf7, 0x68, 0x85, 0x17, 0xa4,
	0xfa, 0x8a, 0x07, 0xb9, 0x96, 0x3b, 0xdb, 0xbf, 0x35, 0x1e, 0xf6, 0x22, 0x49, 0x8e, 0xc2, 0x7e,
	0xef, 0x28, 0xde, 0x7b, 0x94, 0x61, 0x3b, 0xeb, 0xc9, 0x3f, 0xa4, 0x8f, 0xff, 0x0a, 0x00, 0x00,
	0xff, 0xff, 0x5e, 0xec, 0x47, 0xfb, 0x63, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// CommandServiceClient is the client API for CommandService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CommandServiceClient interface {
	// Opens a stream allowing clients to register command handlers and receive commands.
	OpenStream(ctx context.Context, opts ...grpc.CallOption) (CommandService_OpenStreamClient, error)
	// Dispatches the given command, returning the result of command execution
	Dispatch(ctx context.Context, in *Command, opts ...grpc.CallOption) (*CommandResponse, error)
}

type commandServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommandServiceClient(cc grpc.ClientConnInterface) CommandServiceClient {
	return &commandServiceClient{cc}
}

func (c *commandServiceClient) OpenStream(ctx context.Context, opts ...grpc.CallOption) (CommandService_OpenStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CommandService_serviceDesc.Streams[0], "/io.axoniq.axonserver.grpc.command.CommandService/OpenStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &commandServiceOpenStreamClient{stream}
	return x, nil
}

type CommandService_OpenStreamClient interface {
	Send(*CommandProviderOutbound) error
	Recv() (*CommandProviderInbound, error)
	grpc.ClientStream
}

type commandServiceOpenStreamClient struct {
	grpc.ClientStream
}

func (x *commandServiceOpenStreamClient) Send(m *CommandProviderOutbound) error {
	return x.ClientStream.SendMsg(m)
}

func (x *commandServiceOpenStreamClient) Recv() (*CommandProviderInbound, error) {
	m := new(CommandProviderInbound)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *commandServiceClient) Dispatch(ctx context.Context, in *Command, opts ...grpc.CallOption) (*CommandResponse, error) {
	out := new(CommandResponse)
	err := c.cc.Invoke(ctx, "/io.axoniq.axonserver.grpc.command.CommandService/Dispatch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommandServiceServer is the server API for CommandService service.
type CommandServiceServer interface {
	// Opens a stream allowing clients to register command handlers and receive commands.
	OpenStream(CommandService_OpenStreamServer) error
	// Dispatches the given command, returning the result of command execution
	Dispatch(context.Context, *Command) (*CommandResponse, error)
}

// UnimplementedCommandServiceServer can be embedded to have forward compatible implementations.
type UnimplementedCommandServiceServer struct {
}

func (*UnimplementedCommandServiceServer) OpenStream(srv CommandService_OpenStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method OpenStream not implemented")
}
func (*UnimplementedCommandServiceServer) Dispatch(ctx context.Context, req *Command) (*CommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Dispatch not implemented")
}

func RegisterCommandServiceServer(s *grpc.Server, srv CommandServiceServer) {
	s.RegisterService(&_CommandService_serviceDesc, srv)
}

func _CommandService_OpenStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CommandServiceServer).OpenStream(&commandServiceOpenStreamServer{stream})
}

type CommandService_OpenStreamServer interface {
	Send(*CommandProviderInbound) error
	Recv() (*CommandProviderOutbound, error)
	grpc.ServerStream
}

type commandServiceOpenStreamServer struct {
	grpc.ServerStream
}

func (x *commandServiceOpenStreamServer) Send(m *CommandProviderInbound) error {
	return x.ServerStream.SendMsg(m)
}

func (x *commandServiceOpenStreamServer) Recv() (*CommandProviderOutbound, error) {
	m := new(CommandProviderOutbound)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _CommandService_Dispatch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommandServiceServer).Dispatch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/io.axoniq.axonserver.grpc.command.CommandService/Dispatch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommandServiceServer).Dispatch(ctx, req.(*Command))
	}
	return interceptor(ctx, in, info, handler)
}

var _CommandService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "io.axoniq.axonserver.grpc.command.CommandService",
	HandlerType: (*CommandServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Dispatch",
			Handler:    _CommandService_Dispatch_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenStream",
			Handler:       _CommandService_OpenStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "command.proto",
}
